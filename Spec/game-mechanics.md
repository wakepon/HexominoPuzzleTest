# ゲームメカニクス

## 概要

ブロック配置パズルのコアメカニクス（ボード管理、ブロック配置、衝突判定、デッキシステム、ラウンド制、ショップ）について説明する。

## ボード管理

### ボード構造

- 6x6のグリッド（`GRID_SIZE = 6`）
- 各セルは `Cell` 型で表現される
  - `filled: boolean` - セルが埋まっているかどうか

### 空ボード生成

- ゲーム開始時とラウンド開始時に全セルが空の状態でボードが生成される
- すべてのセルの `filled` が `false` で初期化される

### セル状態の取得

- 指定位置のセルを取得する機能
- 範囲外の座標を指定した場合は `null` を返す

## デッキシステム

### デッキの構成

- デッキは複数のミノIDから構成される
- 初期デッキは6枚: `mono-1, dom-h, dom-v, tro-i-h, tro-i-v, tro-l-0`
- ショップで購入したミノがデッキに追加される
- 6枚 / 12ハンド = 2周回転。護符で強化したピースを確実に2回使える
- ピース追加でデッキが7-8枚になっても1.5周以上回る
- 追加しすぎるとデッキ回転率が落ちる → 「追加 vs 圧縮」の判断が戦略になる

> ※現状は初期デッキ9枚（mono-1, dom-h, dom-v, tro-i-h, tro-i-v, tro-l-0, tro-l-90, tro-l-180, tro-l-270）。6枚化は未実装。

### デッキの初期化

- ゲーム開始時に初期デッキミノIDリストが取得される
- Fisher-Yatesアルゴリズムでシャッフルされる
- 配置可能回数が初期値に設定される

### ミノの引き出し

- デッキから指定枚数（通常3枚）のミノIDを引く
- デッキが足りない場合は初期ミノIDリストを再シャッフルして補充
- 引いたミノIDからPieceオブジェクトを生成

### ミノID→Piece変換

- ミノIDから対応するMinoDefinitionを取得
- タイムスタンプと乱数でユニークなPiece IDを生成
- MinoDefinitionの形状を継承してPieceを作成

### 残り配置回数

- ラウンド開始時に配置可能回数が設定される
- ミノを配置するたびに1減少する
- 0になると新しいミノを引けなくなる
- ラウンドクリア時の残り回数がゴールド報酬に影響する

### 自動補充

- 全てのスロットが空になると自動的に新しいミノセット（3個）を引く
- ただし残り配置回数が0の場合は補充されない

## ラウンドシステム

### ラウンド構成

- 全24ラウンド（`ROUND_CONFIG.maxRound`）
- 各ラウンドは独立したゲームプレイ
- ラウンド開始時にボード、スコア、配置回数がリセットされる

### ラウンドセット

3ラウンドで1セットを構成:

| ラウンド位置 | タイプ | ラベル | クリア報酬 |
|--------------|--------|--------|------------|
| 1番目 | normal | 雑魚 | 低 |
| 2番目 | elite | エリート | 中 |
| 3番目 | boss | ボス | 高 |

**セット番号計算:**
```
setNumber = Math.floor((round - 1) / 3) + 1
positionInSet = (round - 1) % 3  // 0, 1, 2
roundType = TYPES[positionInSet]  // normal, elite, boss
```

### ボス特殊条件

ボスラウンドでは以下のいずれかの条件がランダムに適用される:

| ID | 名前 | 効果 |
|----|------|------|
| `obstacle` | おじゃまブロック | ランダムな4マスが埋まっている（消去不可） |
| `energy_save` | 省エネ | 配置可能数が減少（通常の一定割合） |
| `two_cards` | 手札2枚 | 手札が2枚になる（通常3枚） |

**条件の適用:**
```
// 最大配置数
getMaxPlacements() {
    if (isBoss && bossCondition.id === 'energy_save') {
        return 通常の配置数 × ENERGY_SAVE_RATIO（75%）
    }
    return 通常の配置数
}

// ドロー枚数
getDrawCount() {
    if (isBoss && bossCondition.id === 'two_cards') {
        return 2
    }
    return 3
}
```

**おじゃまブロックの配置:**
- ラウンド開始時にランダムな位置に複数マス配置
- セルは `pattern: 'obstacle'` としてマーク（ネガティブパターン）
- ライン消去で消えない

**条件の抽選タイミング:**
- 新しいセットに入る時に抽選
- 同じセット内では条件は固定

### 目標スコア

- 各ラウンドに目標スコアが設定される
- 目標スコアを達成するとラウンドクリア
- 目標スコアはラウンドが進むにつれて増加する（初期値と増加量はパラメータ）

### ラウンドクリア条件

- 現在スコアが目標スコア以上に達する
- 達成時に自動的にround_clearフェーズに遷移

### ラウンドクリア時の処理

1. クリアメッセージを表示
2. ラウンドタイプに応じた報酬を付与
3. ショップ画面を表示（最終ラウンド以外）

### ゲームオーバー条件

- 残り配置回数が0で目標スコア未達成の場合
- 手札のすべてのブロックがどこにも配置できない場合
- game_overフェーズに遷移

### ゲームオーバー時の処理

1. ゲームオーバー画面を表示
2. ハイスコア（最高到達ラウンド）を保存
3. ゴールドを0にリセット
4. レリックをリセット

### ゲームクリア条件

- 最終ラウンド（24ラウンド）をクリア
- game_clearフェーズに遷移

### 次ラウンド開始処理

```
startNextRound() {
    round++
    resetScore()
    clearBoard()

    // ボス条件: おじゃまブロック
    if (isBoss && bossCondition.id === 'obstacle') {
        placeObstacleBlocks()  // 4マスをランダム配置
    }

    resetDeck()
    blocksPlacedCount = 0
    currentBlocks = draw(getDrawCount())

    updateUI()
    checkGameOver()
}
```

## ゴールドシステム

### ゴールド報酬計算

ラウンドクリア時の報酬:

```
goldReward = BASE_REWARD[roundType] + remainingHands + interest
```

- ベース報酬はラウンドタイプごとに異なる（normal: 低、elite: 中、boss: 高）
- 残りハンド数（残り配置回数）がそのまま加算される

### 利息

ラウンドクリア時に所持ゴールドに応じた利息を獲得する。

| 所持ゴールド | 利息 |
|---|---|
| 0〜4G | +0G |
| 5〜9G | +1G |
| 10〜14G | +2G |
| 15〜19G | +3G |
| 20〜24G | +4G |
| 25G以上 | +5G（上限） |

- 利率: 所持ゴールド5Gごとに+1G
- 上限: +5G/ラウンド（=25G以上持っていても+5Gまで）
- 付与タイミング: ラウンドクリア時（ラウンド報酬と同時）
- 「今ラウンドで買うか、貯めて利息を稼ぐか」という判断が生まれる

> ※利息システムは未実装。

### ゴールドの用途

- ショップでミノ・レリック・護符を購入する際に消費される
- ミノの購入価格はセル数に基づく
- レリックの売却で購入価格の半額を回収できる

## ショップシステム

### ショップフェーズ

- ラウンドクリア後にshoppingフェーズに移行（最終ラウンドを除く）
- ゴールド報酬が加算された状態でショップが開かれる

### 商品構成

| 枠 | 内容 | 枠数 |
|---|---|---|
| ピース枠 | 小〜中サイズ / 中〜大サイズ | 2 |
| レリック/護符枠 | レリックと護符がランダムに混在 | 3 |
| **合計** | | **5** |

> ※現状はピース3枠（小/中/大）+ レリック最大3枠。2+3構成は未実装。

### 商品カテゴリ

- **ブロックセット**: 通常ブロック、パターン付き、シール付き
- **レリック**: 恒久的なパッシブ効果アイテム（所持上限5枠）
- **護符**: デッキの質を変える消費アイテム（ストック上限2個）

### ブロックセット商品

#### 通常ブロック

2種類のミノがランダムに選ばれる:

1. **小〜中サイズ**: モノミノ/ドミノ/トロミノ/テトロミノから1つ
2. **中〜大サイズ**: テトロミノ/ペントミノ/ヘキソミノから1つ

価格はセル数に基づいて設定:
- モノミノ: 1ゴールド
- ドミノ: 2ゴールド
- トロミノ: 3ゴールド
- テトロミノ: 4ゴールド
- ペントミノ: 5ゴールド
- ヘキソミノ: 6ゴールド

#### パターン付きブロックセット

ブロック全体に特殊効果が付与される。詳細は[パターン・シールシステム](./pattern-seal-system.md)を参照。

#### シール付きブロックセット

特定のセルに特殊効果が付与される。詳細は[パターン・シールシステム](./pattern-seal-system.md)を参照。

### レリック商品

- レリック/護符3枠にランダムに出現
- 未所持のレリックからランダムに選択
- レリック5枠が埋まっていても表示される（売却→購入の導線）
- すべてのレリックを所持している場合はレリックの代わりに護符が出現
- 詳細は[レリックシステム](./relic-system.md)を参照

### 護符商品

- レリック/護符3枠にランダムに混在して出現
- 購入後はストック（最大2個）に保管される
- 使用タイミング: ショップフェーズ中、またはパズル中

#### 護符の種類

| 護符名 | 効果 | 対象 | 価格帯 |
|---|---|---|---|
| **造形の護符** | ピースの形状をブロック単位のD&Dで変更 | デッキ内の1ピース | 5〜8G |
| **紋様の護符** | ピースにランダムなパターンを追加 | デッキ内の1ピース | 8〜12G |
| **刻印の護符** | ピースのランダムな位置にランダムなシールを追加 | デッキ内の1ピース | 8〜12G |
| **消滅の護符** | ピースをデッキから削除 | デッキ内の1ピース | 3〜5G |

> ※護符システムは未実装。

### 購入処理

#### ブロックセット購入

1. ゴールドを消費
2. 商品を売却済みにマーク
3. デッキにブロックを追加（パターン・シール情報付き）
4. UI更新

#### レリック購入

1. ゴールドを消費（5枠に空きがある場合のみ購入可能）
2. 商品を売却済みにマーク
3. レリックを所持リストに追加
4. UI更新

> ※5枠満杯時は売却するレリックを選択 → 売却後に購入。現状は所持上限なし。

#### 護符購入

1. ゴールドを消費（ストックに空きがある場合のみ購入可能）
2. 商品を売却済みにマーク
3. 護符ストックに追加
4. UI更新

> ※護符購入は未実装。

#### レリック売却

1. ショップフェーズ中に所持レリックを選択
2. 売却確認
3. 購入価格の半額（端数切り捨て）のゴールドを獲得
4. レリックを所持リストから除去
5. UI更新

> ※レリック売却は未実装。

#### 購入条件

- 所持ゴールドが価格以上
- 商品が未購入

### ショップ退出

- 「次へ」または「ショップを出る」ボタンで次のラウンドに進む
- 購入は必須ではない（何も買わずに進行可能）
- デッキがシャッフルされ、配置回数がリセットされる
- ボードとスコアがリセットされる
- ラウンド進行画面を表示

## ミノ形状システム

### ミノカテゴリ

ミノはセル数によって6つのカテゴリに分類される:

1. **モノミノ**: 1セル - 1種類
2. **ドミノ**: 2セル - 2種類（横・縦）
3. **トロミノ**: 3セル - 6種類
4. **テトロミノ**: 4セル - 19種類
5. **ペントミノ**: 5セル - 63種類
6. **ヘキソミノ**: 6セル - 216種類（35基本形 × 回転・反転）

**合計**: 307種類のミノ定義

### ミノ定義データ構造

- `MinoDefinition`: ミノの定義
  - `id`: ミノの識別子（例: `"hex-K20-m90"`）
  - `category`: カテゴリ（`'monomino'` ~ `'hexomino'`）
  - `shape`: 2次元配列の真偽値（`true` = ブロックあり）
  - `cellCount`: セル数

### ASCII形状定義

ミノ形状はASCIIアート形式で定義される:
- `#`: ブロックあり
- `.`: 空セル
- 各行の長さが異なる場合、最大幅に合わせて自動パディング

### ブロック生成

`Piece` オブジェクトは `MinoDefinition` から生成される:
- ユニークID: タイムスタンプ + 乱数で生成
- 形状: ミノ定義から継承

## ブロック配置

### 配置処理

- 指定位置にブロックを配置する（immutableパターン）
- 新しいボードオブジェクトを返す（元のボードは変更しない）
- ブロック形状の各セルが `true` の位置に対応するボードセルを `filled: true` に設定する

### 前提条件

配置処理を実行する前に、必ず衝突判定で配置可能かチェックする必要がある。

### 配置後の処理

1. スロットからブロックを削除
2. 残り配置回数を1減少
3. 全スロットが空かつ残り配置回数が0より大きい場合、新しいミノセットを引く
4. ライン完成を判定
5. スコアとフェーズを更新

## 衝突判定

### 配置可能性チェック

以下の条件をすべて満たす場合に配置可能と判定される:

1. **範囲内チェック**: ブロックのすべてのセルがボード範囲内に収まる
2. **重複チェック**: ブロックのセルと既に埋まっているセルが重複しない

### チェック処理

- ブロック形状の各セル（`true` のセル）に対して判定を実行
- 1つでも条件を満たさないセルがあれば配置不可と判定

### 座標変換

スクリーン座標（ピクセル単位）からボード座標（グリッド単位）への変換機能を提供:

- ドラッグ位置をボード上のグリッド位置に変換
- ボードオフセットとセルサイズを考慮した計算
- `Math.floor` で切り捨て処理

### ボード範囲チェック

- 指定座標がボード範囲内（0 ~ GRID_SIZE-1）かを判定する独立した関数

## ドラッグ&ドロップ

### ドラッグ開始

1. プレイヤーがブロックスロット上でマウス/タッチを開始
2. スロットインデックスと開始位置を記録
3. ドラッグ状態を有効化
4. playingフェーズでのみドラッグ可能

### ドラッグ中

1. マウス/タッチ位置を追跡
2. 現在位置をスクリーン座標からボード座標に変換
3. 変換されたボード座標で配置可能性をチェック
4. プレビュー表示を更新

### ドラッグ終了

1. ドロップ時のボード座標を取得
2. 配置可能かチェック
   - **配置可能**: ブロックをボードに配置し、スロットから削除
   - **配置不可**: 何も変更せずドラッグ状態をクリア
3. playingフェーズでない場合は配置不可

## プレビュー表示

### プレビュー判定

- ドラッグ中のみプレビューを表示
- ボード座標が取得できている場合のみ表示
- 配置可能性に応じて色を変更

### プレビュー色

- **配置可能**: 半透明の茶色系（`previewValid`）
- **配置不可**: 半透明の赤色（`previewInvalid`）

### 描画範囲

- プレビューはボード範囲内のセルのみ描画
- ブロック形状の各 `true` セルに対応する位置に描画

## ライン消去システム

### ライン完成判定

- **行**: すべてのセルが埋まっている行を検出
- **列**: すべてのセルが埋まっている列を検出
- 複数ラインの同時検出が可能

### 消去対象外

以下のセルはライン消去から除外される:

- **石シール付きセル**: `seal === 'stone'`（`preventsClearing` フラグ）
- **ネガティブパターンのセル**: `pattern === 'obstacle'` 等（`isNegative` フラグ）

これらのセルが含まれている行・列は完成とみなされない。

### 消去対象セル決定

- 完成した行と列のセルを収集
- 重複するセル（行と列が交差する位置）は1回のみカウント
- `Set` を使用して重複を除去
- その後、石シール・ネガティブパターンのセルをフィルタリング

## コンボカウンター

- ライン消去が発生した回数をラウンド内で累積するカウンター
- ライン消去が発生するたびにコンボカウントが増加する
- コンボカウントはコンボボーナス（`combo` パターン効果）とは別の概念で、`calculateScoreBreakdown` に渡される
- 詳細な条件はゲーム状態管理に依存する

## スコア計算

### 用語定義

| 用語 | 変数名 | 説明 |
|------|--------|------|
| **ブロック点 (A)** | `blockPoints` | 消去ブロック数にパターン・シール効果と加算レリック・コンボを加えた値 |
| **列点 (B)** | `linePoints` | 消去ライン数にlucky・moss・台本加算を加え、乗算レリックを適用した値 |
| **列倍率** | — | 列点(B)に対して適用される各種乗算レリック効果の総称 |

### 計算式（A×B方式）

最終スコアはブロック点(A)と列点(B)の積で決定される:

```
最終スコア = Math.floor( ブロック点(A) × 列点(B) )
```

### 計算フロー概要

```
1. 消去対象セルを収集（石シール・ネガティブパターン除外）
2. パターン効果を計算（ブロック点・列点への加算を決定）
3. シール効果を計算（multi/arrow/score→ブロック点、gold→ゴールド）
4. ブロック点(A) = totalBlocks + sealScoreBonus + 加算レリック + comboBonus
5. 列点(B) = linesCleared × luckyMultiplier + mossBonus + 台本加算 × 乗算レリック
6. 最終スコア = Math.floor(A × B)
```

### totalBlocks（基礎ブロック数）の計算

```
totalBlocks =
  baseBlocks            // 消去対象セル数
  - chargeBlockCount    // chargeブロックの基礎分を除外
  + enhancedBonus       // enhanced効果（+2/個、multi付きで+4）
  + auraBonus           // aura効果（隣接別セットauraで+1、multi付きで+2）
  + chargeBonus         // charge蓄積値合計（multi付きで2倍）
  + multiBonus          // multiシール効果（+1/個）
  + arrowBonus          // arrowシール効果（対応ライン完成時+10/個）
```

※ mossBonus は列点(B)に加算される（totalBlocksには含まれない）

### パターン効果

#### ブロック点(A)に影響するパターン

| パターンID | 効果 | multiシール |
|-----------|------|------------|
| `enhanced` | ブロック点+2/個 | +4/個 |
| `aura` | 隣接する別セットauraブロックがあるセルはブロック点+1（1セルあたり上限+1） | +2 |
| `charge` | 基礎ブロック数から除外され、chargeValue合計をブロック点に加算 | 2倍 |
| `combo` | 同時消去comboブロック数nに応じて `2^n - 1` をブロック点に加算 | 1個が2カウント |

#### 列点(B)に影響するパターン

| パターンID | 効果 | multiシール |
|-----------|------|------------|
| `moss` | 端接触辺数だけ列点に加算（角で+2、辺で+1） | 2倍 |
| `lucky` | 10%の確率でluckyMultiplier=2（列点の起点値が2倍） | 2回抽選 |

#### スコアに影響しないパターン

| パターンID | 効果 |
|-----------|------|
| `nohand` | 配置時にハンドを消費しない |
| `feather` | 既存ブロックの上に重ね置き可能 |
| `obstacle` | ネガティブパターン。消去不可 |

### シール効果

| シールID | 影響先 | 効果 |
|---------|--------|------|
| `multi` | ブロック点(A) | ブロック点+1/個（2回カウント）。加えてパターン効果を2倍化 |
| `arrow_v` | ブロック点(A) | 縦列完成時にブロック点+10/個 |
| `arrow_h` | ブロック点(A) | 横行完成時にブロック点+10/個 |
| `score` | ブロック点(A) | ブロック点+5/個 |
| `gold` | — | ゴールド+1/個（スコアに影響しない） |
| `stone` | — | 消去対象から除外（ライン完成を阻害） |

### コンボボーナス

消去対象に含まれる `combo` パターンのブロック数に応じて指数的にブロック点(A)を加算する:

```
comboBonus = 2^n - 1  (n = comboブロック数、multiシール付きは2カウント)

例: 1個→+1, 2個→+3, 3個→+7, 4個→+15
```

- comboパターンのブロックが消去対象に含まれていなければ0
- multiシール付きcomboブロックは2個としてカウント

### luckyパターン

- 消去対象に `lucky` パターンのセルが含まれる場合、10%の確率で当選
- 当選時: luckyMultiplier=2（列点(B)の起点計算で `linesCleared × 2` になる）
- 外れ: luckyMultiplier=1（通常通り）
- multiシール付きluckyブロックは2回抽選（どちらか1回でも当たれば2倍）

### ブロック点(A)の詳細計算

```
blockPoints = totalBlocks + sealScoreBonus

// relicDisplayOrder順に加算レリックを適用:
//   + sizeBonusTotal（サイズボーナス発動時: baseBlocks）
//   + copyBonus（コピーが加算系対象の場合）

blockPoints += comboBonus
```

- scoreシール（+5/個）はブロック点(A)に直接加算される
- サイズボーナス発動時は消去ブロック数（baseBlocks）をそのまま加算
- comboBonus（2^n - 1）は最後にブロック点に加算

### 列点(B)の詳細計算

```
linePoints = linesCleared × luckyMultiplier + mossBonus

// relicDisplayOrder順に台本加算・乗算レリックを適用:
//   + scriptLineBonus（台本: 1本→+1、2本→+2）
//   + copyLineBonus（コピーが台本対象の場合）
//   × 各乗算レリック倍率（切り捨てなし）
//   × copyMultiplier（コピーが乗算系対象の場合、対象直後）
```

- mossBonus は列点(B)の起点値に加算される
- 乗算レリックは切り捨てなしで順次適用される

### 列倍率（乗算レリック → 列点(B)に乗算）

乗算レリックは列点(B)に対して `relicDisplayOrder`（所持レリックの表示順）に従って順番に適用される。各ステップでは切り捨てなしで乗算される。

| レリックID | 発動条件 | 列倍率 |
|-----------|---------|--------|
| `chain_master` | 2ライン以上同時消去 | 列点×1.5 |
| `single_line` | 1ラインのみ消去 | 列点×3 |
| `takenoko` | 縦列のみ消去（横行なし） | 列点×消去列数 |
| `kani` | 横行のみ消去（縦列なし） | 列点×消去行数 |
| `nobi_takenoko` | 縦列のみ消去 | 列点×累積倍率（+0.5ずつ増加、横行消しで1.0にリセット） |
| `nobi_kani` | 横行のみ消去 | 列点×累積倍率（+0.5ずつ増加、縦列消しで1.0にリセット） |
| `rensha` | ライン消去時 | 列点×累積倍率（+1ずつ増加、消去なしで1.0にリセット） |
| `timing` | 残りハンド数が3の倍数かつライン消去あり | 列点×3 |
| `full_clear_bonus` | 盤面を全て空にした場合 | 列点×5 |
| `copy` | 1つ上のレリックが乗算系 | 対象と同じ倍率をコピーして乗算 |

**コピーレリックの乗算タイミング:** コピー対象レリックの直後に乗算が適用される（`relicDisplayOrder` 順）。

### レリック効果（加算系 → ブロック点(A)に加算）

relicDisplayOrder順にブロック点(A)に加算される:

| レリックID | 発動条件 | 効果 |
|-----------|---------|------|
| `size_bonus_1` ～ `size_bonus_6` | 対応サイズのピースでライン消去 | 消去ブロック数（baseBlocks）をブロック点に加算 |
| `copy` | コピー対象が加算レリックの場合 | 対象レリックと同じ加算量をコピーして加算 |

※ `full_clear_bonus` は乗算レリック（列点×5）に変更されています。

### レリック効果（ライン数加算系）

台本レリックはライン数を加算する（基本スコア計算に影響）:

| レリックID | 発動条件 | 効果 |
|-----------|---------|------|
| `script` | ラウンド開始時指定の2本のラインを揃えた場合 | 1本揃いでライン数を+1、2本同時揃いでライン数を+2 |
| `copy` | コピー対象が台本レリックの場合 | 対象レリックと同じライン数加算をコピーして加算 |

### 最終スコアの計算

```
finalScore = Math.floor( blockPoints × linePoints )
```

- ブロック点(A)と列点(B)の積を切り捨てたものが最終スコア
- 各乗算レリックは列点(B)に対して切り捨てなしで順次適用される
- 最後の `Math.floor` のみで切り捨てが行われる

### スコア計算フロー（詳細）

```
1. cellsToRemove = getCellsToRemoveWithFilter(board, completedLines)
   （石シール・ネガティブパターン除外済み）

2. パターン効果計算:
   enhancedBonus = enhanced付きセル数 × 2（multi付きなら×4）
   auraBonus     = 隣接に別セットauraがある消去セル数（multi付きなら+2）
   chargeBonus   = charge付きセルのchargeValue合計（multi付きなら2倍）
   mossBonus     = moss付きセルの端接触辺数合計（multi付きなら2倍）

3. シール効果計算:
   multiBonus     = multi付きセル数（+1/個）
   arrowBonus     = 対応ライン完成時のarrow付きセル × 10
   sealScoreBonus = score付きセル数 × 5
   goldCount      = gold付きセル数（ゴールド付与用）

4. totalBlocks = baseBlocks - chargeBlockCount
                + enhancedBonus + auraBonus + chargeBonus
                + multiBonus + arrowBonus
   ※ mossBonus は列点(B)に加算されるため、ここには含まれない

5. ブロック点(A):
   blockPoints = totalBlocks + sealScoreBonus
   relicDisplayOrder順に加算レリックを適用:
     + sizeBonusTotal（サイズボーナス発動時: baseBlocks）
     + copyBonus（コピーが加算系対象の場合）
   blockPoints += comboBonus（2^n - 1, n=comboブロック数）

6. 列点(B):
   linePoints = linesCleared × luckyMultiplier + mossBonus
   relicDisplayOrder順に台本加算・乗算レリックを適用:
     + scriptLineBonus（台本: 1本→+1、2本→+2）
     + copyLineBonus（コピーが台本対象の場合）
     × 各乗算レリック倍率（切り捨てなし）
     × copyMultiplier（コピーが乗算系対象の場合、対象直後）

7. 最終スコア = Math.floor(blockPoints × linePoints)
```

### スコア演出

1. 画面中央に計算式表示
2. パターンボーナスがあれば段階的に表示
3. レリック効果があれば倍率・ボーナス表示
4. スコアカウンターのアニメーション
5. 消去されるブロック上にポップアップ表示

### スコアとフェーズ判定

- ライン消去後、スコアが目標スコア以上ならround_clearフェーズに遷移
- 残り配置回数が0かつ目標未達成ならgame_overフェーズに遷移

### ライン消去実行

- 消去対象セルを `filled: false` に設定
- 新しいボードオブジェクトを返す（immutable）

## 消去アニメーション

### アニメーション効果

- 回転: 0度から180度まで
- 上昇: セルが上方向に移動
- 縮小: スケールが1.0から0.0に変化
- イージング: ease-out cubic

### アニメーション状態

- `isAnimating`: アニメーション中フラグ
- `cells`: 消去対象セル配列
- `startTime`: 開始時刻（タイムスタンプ）
- `duration`: 継続時間

### 描画タイミング

- アニメーション中は `requestAnimationFrame` でループ
- 進行度に応じてセルを変形・描画
- 完了時に `END_CLEAR_ANIMATION` アクションで実際の消去を実行

## 配置不可検出

### 検出タイミング

- ブロック配置後
- 新しい手札をドロー後

### 処理フロー

1. すべての手札ブロックについて、ボード上のすべての位置で配置可否判定
2. 1つも配置できない場合、ダイアログ表示
3. 配置不可能なブロックをすべて「配置済み」扱い（配置カウント増加）
4. 配置カウントが上限に達していればラウンド終了処理
5. そうでなければ次のブロックをドロー
6. 再度チェック

### ダイアログ表示

- 配置不可能であることを通知
- 一定時間後にコールバック実行

## 乱数生成器

2種類の乱数生成器を提供:
- `DefaultRandom`: `Math.random()` のラッパー（本番環境用）
- `SeededRandom`: シード対応（テスト用、Mulberry32アルゴリズム）

用途:
- デッキのシャッフル
- ショップアイテムの選択
- ボス条件の抽選

## 関連ファイル

- `src/lib/game/Services/LineService.ts` - ライン消去ロジック
- `src/lib/game/Services/RoundService.ts` - ラウンド管理・ゴールド計算
- `src/lib/game/Data/Constants.ts` - ゲーム定数
- `src/lib/game/Data/BossConditions.ts` - ボス条件マスターデータ
- `src/lib/game/Domain/Effect/RelicEffectHandler.ts` - レリック効果計算
- `src/lib/game/Domain/Effect/Relic.ts` - レリック定義・RELIC_EFFECT_VALUES
- `src/lib/game/Domain/Effect/PatternEffectHandler.ts` - パターン効果計算・スコア計算統合
- `src/lib/game/Domain/Effect/SealEffectHandler.ts` - シール効果計算

## 更新履歴

- 2026-02-19: スコア計算をA×B方式（ブロック点×列点）に全面書き直し。用語定義（ブロック点/列点/列倍率）追加、mossBonus→列点(B)、comboBonus→2^n-1、full_clear_bonus→列点×5（乗算）、rensha増分+1、multiシールのパターン効果2倍化を明記
- 2026-02-18: 台本レリック効果を「スコア加算」から「ライン数加算」に変更（scriptBonus → scriptLineBonus、copyLineBonus追加、effectiveLinesCleared計算追加）
- 2026-02-17: コードに基づき全面更新（ボス条件おじゃまブロック数修正、全消しボーナス+100に修正、スコア計算式を全レリック・パターン・シール反映で更新、コンボカウンター追加、ゴールド報酬計算式更新、連射増分+2・全消しボーナス+100を反映、legiDisplayOrder適用順序を明記）
- 2026-02-17: レリック中心設計を反映（デッキ6枚化、利息、ショップ2+3構成、レリック売却、護符商品・購入フロー追加）
- 2026-02-06: ローグライト要素追加（ラウンドセット、ボス条件、パターン・シール効果、レリック効果、ショップ拡張、配置不可検出）
- 2026-02-02: デッキシステム、ラウンド制、ゴールド、ショップ、フェーズ判定を追加
- 2026-02-01: ミノシステム、生成ロジック、ライン消去、アニメーションを追加
- 2026-02-01: 初版作成
