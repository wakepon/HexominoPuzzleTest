---
description: 縦スライス（Vertical Slice）アプローチで実装計画を作成。機能単位で型→ロジック→UIを一気に実装し、各スライス完了後に画面で動作確認できる計画を立てる。
---

# Vertical Slice Plan コマンド

このコマンドは **縦スライスアプローチ** で実装計画を作成します。
従来の横スライス（全型定義→全ロジック→全UI）ではなく、機能単位で全レイヤーを実装し、各スライス完了後に画面で動作確認できる計画を立てます。

## 縦スライスアプローチとは

```
従来のアプローチ（横スライス）:
┌─────────────────────────────────────┐
│ 1. 全ての型定義                      │ ← 画面なし
├─────────────────────────────────────┤
│ 2. 全てのロジック                    │ ← 画面なし
├─────────────────────────────────────┤
│ 3. 全てのUI                          │ ← やっと動作確認
└─────────────────────────────────────┘

縦スライスアプローチ:
┌─────────┬─────────┬─────────┬─────────┐
│ 機能A   │ 機能B   │ 機能C   │ 機能D   │
│ ─────── │ ─────── │ ─────── │ ─────── │
│ 型      │ 型      │ 型      │ 型      │
│ ロジック │ ロジック │ ロジック │ ロジック │
│ UI      │ UI      │ UI      │ UI      │
│ ↓確認   │ ↓確認   │ ↓確認   │ ↓確認   │
└─────────┴─────────┴─────────┴─────────┘
```

## 使用タイミング

`/vertical-slice-plan` を使用する場面:
- 新規プロジェクトの実装計画を立てる時
- 大きな機能追加で複数画面が関わる時
- 早い段階から画面で動作確認したい時
- アジャイル/イテレーティブに開発したい時

## 実行手順

1. **仕様書を読み込む**
   - `Spec/` ディレクトリの仕様書を確認
   - 機能一覧と画面一覧を把握

2. **スライスを定義する**
   - 画面/機能単位でスライスを分割
   - 各スライスは独立して動作確認できる単位
   - 依存関係を考慮して順序を決定

3. **各スライスのタスクを定義する**
   - 必要な型定義
   - 必要なロジック
   - 必要なUIコンポーネント
   - 動作確認ポイント

4. **計画をMarkdownで出力する**
   - `Spec/MVP/ImplementationTasks.md` に書き出し
   - 各スライスの動作確認ポイントを明記

## 出力フォーマット

```markdown
# 実装タスク一覧（縦スライスアプローチ）

## 概要
- 技術スタック: [使用技術]
- アプローチ: 縦スライス

---

## スライス1: [機能名]
**動作確認**: [何ができれば完了か]

| # | タスク | 説明 | ステータス |
|---|--------|------|:----------:|
| 1.1 | [タスク名] | [説明] | ⬜ 未着手 |
| 1.2 | [タスク名] | [説明] | ⬜ 未着手 |

---

## スライス2: [機能名]
...

---

## 進捗サマリー

| スライス | 完了タスク | 総タスク | 進捗 |
|---------|-----------|---------|------|
| 1: [機能名] | 0 | X | 0% |
| 2: [機能名] | 0 | Y | 0% |
| **合計** | **0** | **Z** | **0%** |

---

## 各スライスの実装フロー

1. 必要な型定義を追加
2. 必要なロジックを実装
3. 必要なUIコンポーネントを実装
4. 画面に統合
5. ビルド確認（npx tsc --noEmit）
6. 画面で動作確認（npm run dev）
7. 問題があれば修正
8. 次のスライスへ
```

## スライス分割の原則

1. **画面単位で分ける**: タイトル画面、戦闘画面、ストア画面など
2. **依存関係を考慮**: 基盤となる機能を先に実装
3. **動作確認可能な単位**: 各スライス完了後に何かが動く
4. **適度な粒度**: 1スライス = 3〜10タスク程度

## 良いスライスの例

```
スライス1: タイトル画面 + 基盤構築
→ 動作確認: タイトル画面が表示され、ボタンが押せる

スライス2: メイン画面の基本表示
→ 動作確認: メイン画面にデータが表示される

スライス3: メイン画面の操作
→ 動作確認: ユーザー操作で状態が変化する
```

## 悪いスライスの例

```
スライス1: 全ての型定義
→ ❌ 画面で確認できない

スライス2: 全てのユーティリティ関数
→ ❌ 画面で確認できない
```

## 注意事項

- **計画は必ずユーザーに確認** してから実装に進む
- スライス間で共有するコードは早いスライスで実装
- 各スライスの動作確認ポイントを明確にする
- 必要に応じてスライスの順序を調整可能

## 関連コマンド

- `/plan` - 通常の実装計画（横スライス的）
- `/orchestrate` - 計画に基づいて実装を進める
